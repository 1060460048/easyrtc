<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: easyrtc.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: easyrtc.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>

/** @class
 *@version 0.8.0 
 *&lt;p>
 * Provides client side support for the easyRTC framework.
* Please see the easyrtc_client_api.md and easyrtc_client_tutorial.md
* for more details.&lt;/p>
*
*&lt;/p>
*copyright Copyright (c) 2013, Priologic Software Inc.
*All rights reserved.&lt;/p>
*
*&lt;p>
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions are met:
*&lt;/p>
* &lt;ul>
*   &lt;li> Redistributions of source code must retain the above copyright notice,
*      this list of conditions and the following disclaimer. &lt;/li>
*   &lt;li> Redistributions in binary form must reproduce the above copyright
*      notice, this list of conditions and the following disclaimer in the
*      documentation and/or other materials provided with the distribution. &lt;/li>
*&lt;/ul>
*&lt;p>
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
*IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
*ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
*LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
*CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
*SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
*INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
*CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
*ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*POSSIBILITY OF SUCH DAMAGE.
*&lt;/p>
*/
var easyRTC = {};

easyRTC.apiVersion = "0.8.0";

/** Regular expression pattern for user ids. This will need modification to support non US character sets */
easyRTC.userNamePattern = /^[a-zA-Z0-9][a-zA-Z0-9_.-]{0,30}[a-zA-Z0-9]$/;

/** @private */
easyRTC.userName = null;

/** @private */
easyRTC.apiKey = "cmhslu5vo57rlocg"; // default key for now

/** @private */
easyRTC.loggingOut = false;

/** @private */
easyRTC.disconnecting = false;

/** @private */
easyRTC.localStream = null;

/** @private */
easyRTC.videoFeatures = true; // default video 

/** @private */
easyRTC.mozFakeStream = null; // used for setting up datachannels with firefox

/** @private */
easyRTC.audioEnabled = true;

/** @private */
easyRTC.videoEnabled = true;

/** @private */
easyRTC.localVideoWidth = 0;

/** @private */
easyRTC.localVideoHeight = 0;

/** @private */
easyRTC.datachannelName = "dc";

/** @private */
easyRTC.debugPrinter = null;

/** Checks if the supplied string is a valid user name (standard identifier rules)
 * @param {String} name
 * @return {Boolean} true for a valid user name
 * @example
 *    var name = document.getElementById('nameField').value;
 *    if( !easyRTC.isNameValid(name)) {
 *        alert("Bad user name");
 *    }
 */
easyRTC.isNameValid = function(name){
    return easyRTC.userNamePattern.test(name);
}


/** This function is used to set the dimensions of the local camera, usually to get HD.
 *  If called, it must be called before calling easyRTC.initLocalMedia (explicitly or implicitly).
  *  assuming it is supported. If you don't pass any parameters, it will default to 720p dimensions.
  * @param {Number} width in pixels
  * @param {Number} height in pixels
  * @example:
  *    easyRTC.setVideoDims(1280,720);
  * @example:
  *    easyRTC.setVideoDims();
  */
easyRTC.setVideoDims = function(width, height) {
    if( !width) {
        width = 1280;
        height = 720;
    }
    
    easyRTC.videoFeatures = {
        mandatory:{
            minWidth:width, 
            minHeight:height,
            maxWidth:width,
            maxHeight:height
        }
    };    
}

/** This function requests that screen capturing be used to provide the local media source
 * rather than a webcam. If you have multiple screens, they are composited side by side.
 * @example
 *    easyRTC.setScreenCapture();
 */
easyRTC.setScreenCapture = function() {
    easyRTC.videoFeatures = {
        mandatory:{
            chromeMediaSource: "screen"
        }
    };        
}

/** Set the API Key. The API key identifies the owner of the application. 
 *  The API key has no meaning for the Open Source server.
 * @param {String} key 
 * @example
 *      easyRTC.setApiKey('cmhslu5vo57rlocg');
 */
easyRTC.setApiKey = function(key) {
    easyRTC.apiKey = key;  
};

/** Set the application name. Applications can only communicate with other applications
 * that share the sname API Key and application name. There is no predefined set of application
 * names. Maximum length is
 * @param {String} name
 * @example
 *    easyRTC.setApplicationName('simpleAudioVideo');
 */
easyRTC.setApplicationName = function(name) {
    easyRTC.applicationName = name;
}

/** Enable or disable logging to the console. 
 * Note: if you want to control the printing of debug messages, override the
 *    easyRTC.debugPrinter variable with a function that takes a message string as it's argument.
 *    This is exactly what easyRTC.enableDebug does when it's enable argument is true.
 * @param {Boolean} enable - true to turn on debugging, false to turn off debugging. Default is false.
 * @example
 *    easyRTC.enableDebug(true);  
*/  
easyRTC.enableDebug = function(enable) {
    if( enable) {
        easyRTC.debugPrinter = function(message) {
            var stackFrameStrings = new Error().stack.split('\n');
            var srcLine = "";
            if( stackFrameStrings.length >= 3) {
                srcLine = stackFrameStrings[2];
            }
            console.log("debug " + (new Date()).toISOString() +" : " + message + " [" + srcLine + "]");
        }        
    }
    else {
        easyRTC.debugPrinter = null;
    }
}



if( navigator.mozGetUserMedia) {
    easyRTC.datachannelConstraints = {};
}
else {
    easyRTC.datachannelConstraints = {
        reliable:false
    };    
}

/** @private */
easyRTC.haveAudioVideo = {
    audio:false, 
    video:false
};

/** @private */
easyRTC.dataEnabled = false;
/** @private */
easyRTC.serverPath = null;
/** @private */
easyRTC.loggedInListener = null;
/** @private */
easyRTC.onDataChannelOpen = null;
/** @private */
easyRTC.onDataChannelClose = null;
/** @private */
easyRTC.lastLoggedInList = {};
/** @private */
easyRTC.receiveDataCB = null;
/** @private */
easyRTC.updateConfigurationInfo = function() {};  // dummy placeholder for when we aren't connected
//
//
//  easyRTC.peerConns is a map from caller names to the below object structure
//     {  startedAV: boolean,  -- true if we have traded audio/video streams
//        dataChannel: RTPDataChannel if present
//        dataChannelRead: true if the data channel can be used for sending yet
//        connectTime: timestamp when the connection was started
//        sharingAudio: true if audio is being shared
//        sharingVideo: true if video is being shared
//        cancelled: temporarily true if a connection was cancelled by the peer asking to initiate it.
//        candidatesToSend: SDP candidates temporarily queued 
//        pc: RTCPeerConnection
//	  function callSuccessCB(string) - see the easyRTC.call documentation.
//        function callFailureCB(string) - see the easyRTC.call documentation.
//        function wasAcceptedCB(boolean,string) - see the easyRTC.call documentation.
//     }
//
/** @private */
easyRTC.peerConns = {};
//
// a map keeping track of whom we've requested a call with so we don't try to 
// call them a second time before they've responded.
//
/** @private */
easyRTC.acceptancePending = {};

/**
 * Disconnect from the easyRTC server.
 */
easyRTC.disconnect = function() {};

/** @private */
easyRTC.acceptCheck = function(caller, helper) {
    helper(true);
};


/** @private */
easyRTC.streamAcceptor = null;

/** @private */
easyRTC.onStreamClosed = null;

/** @private */
easyRTC.callCancelled = null;

/** Default error reporting function. The default implementation displays error messages
 *  in a programatically created div with the id easyRTCErrorDialog. The div has title
 *  component with a classname of easyRTCErrorDialog_title. The error messages get added to a
 *  container with the id easyRTCErrorDialog_body. Each error message is a text node inside a div
 *  with a class of easyRTCErrorDialog_element. There is an "okay" button with the className of easyRTCErrorDialog_okayButton.
 *  @param {String} message the error message text without any markup.
 *  @example
 *      easyRTC.onError("Invalid username");
 */
easyRTC.onError = function(message) {
    if(easyRTC.debugPrinter) {
        easyRTC.debugPrinter("saw error " + message);
    }
    var errorDiv = document.getElementById('easyRTCErrorDialog');
    var errorBody;
    if( !errorDiv) {
        errorDiv = document.createElement("div");
        errorDiv.id = 'easyRTCErrorDialog';
        
        var title = document.createElement("div");
        title.innerHTML = "Error messages";
        title.className = "easyRTCErrorDialog_title";
        errorDiv.appendChild(title);
        
        errorBody = document.createElement("div");
        errorBody.id = "easyRTCErrorDialog_body";
        errorDiv.appendChild(errorBody);
    
        var clearButton = document.createElement("button");
        clearButton.appendChild( document.createTextNode("Okay"));
        clearButton.className = "easyRTCErrorDialog_okayButton";
        clearButton.onclick = function() {
            errorBody.innerHTML = ""; // remove all inner nodes
            errorDiv.style.display = "none";            
        }    
        errorDiv.appendChild(clearButton);
        document.body.appendChild(errorDiv);

    }
    
    errorBody = document.getElementById("easyRTCErrorDialog_body");
    var messageNode = document.createElement("div");
    
    messageNode.className = 'easyRTCErrorDialog_element';
    messageNode.appendChild( document.createTextNode(message));
    errorBody.appendChild( messageNode);
    
    errorDiv.style.display = "block";
};

//
// add the style sheet to the head of the document. That way, developers
// can overide it.
//
(function(){
    var easySheet = document.createElement("link");        
    easySheet.setAttribute("rel", "stylesheet");
    easySheet.setAttribute("type", "text/css");
    easySheet.setAttribute("href", "../css/easyrtc.css");
    var headSection = document.getElementsByTagName("head")[0];
    var firstHead = headSection.childNodes[0];
    headSection.insertBefore(easySheet, firstHead);
})();


/** @private */
easyRTC.videoBandwidthString = "b=AS:50"; // default video band width is 50kbps


/** @private */
easyRTC.createObjectURL = function(mediaStream) {
    if( window.URL && window.URL.createObjectURL ) {
        return window.URL.createObjectURL(mediaStream);
    }
    else if( window.webkitURL && window.webkitURL.createObjectURL ) {
        return window.webkit.createObjectURL(mediaStream);
    }
    else {
        var errMessage = "Your browsers does not support URL.createObjectURL.";    
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("saw exception " + errMessage);
        }
        throw errMessage;
    }
};


/**
 * A convenience function to ensure that a string doesn't have symbols that will be interpreted by HTML.
 * @param {String} idString
 * @return {String}
 * @example
 *     console.log( easyRTC.cleanId('&hello'));
 */
easyRTC.cleanId = function(idString) {
    var MAP = {
        '&': '&amp;',
        '&lt;': '&lt;',
        '>': '&gt;'
    };

    return idString.replace(/[&&lt;>]/g, function(c) {
        return MAP[c];
    });
};




/** Set the callback that will be invoked when the list of people logged in changes.
 * The callback expects to receive a map whose ideas are easyrtcids and whose values are in turn maps
 * supplying user specific information. The inner maps have the following keys:
 *  userName, applicationName, browserFamily, browserMajor, osFamily, osMajor, deviceFamily.
 * @param {Function} listener
 * @example
 *   easyRTC.setLoggedInListener( function(list) {
 *      for( var i in list ) {
 *         console.log("easyrtcid=" + i + " belongs to user " + list[i].userName);
 *      }
 *   });
 */ 
easyRTC.setLoggedInListener = function(listener) {
    easyRTC.loggedInListener = listener;
};

/**
 * Sets a callback that is called when a data channel is open and ready to send data.
 * The callback will be called with an easyrtcid as it's sole argument.
 * @param {Function} listener
 * @example
 *    easyRTC.setDataChannelOpenListener( function(easyrtcid) {
 *         easyRTC.sendDataP2P(easyrtcid, "hello");
 *    });
 */
easyRTC.setDataChannelOpenListener = function(listener) {
    easyRTC.onDataChannelOpen = listener;
};


/** Sets a callback that is called when a previously open data channel closes.
 * The callback will be called with an easyrtcid as it's sole argument.
 * @param {Function} listener
 * @example
 *    easyRTC.setDataChannelCloseListener( function(easyrtcid) {
 *            console.log("No longer connected to " + easyRTC.idToName(easyrtcid));       
 *    });
 */
easyRTC.setDataChannelCloseListener = function(listener) {
    easyRTC.onDataChannelClose = listener;
};

/** Returns the number of live peer connections the client has.
 * @return {Number}
 * @example
 *    console.log("You have " + easyRTC.getConnectionCount() + " peer connections");
 */
easyRTC.getConnectionCount = function() {
    var count = 0;
    for(var i in easyRTC.peerConns ) {
        if( easyRTC.peerConns[i].startedAV ) {
            count++;
        }
    }
    return count;
};


/** Sets whether audio is transmitted by the local user in any subsequent calls.
 * @param {Boolean} enabled true to include audio, false to exclude audio. The default is true.
 * @example
 *      easyRTC.enableAudio(false);
 */
easyRTC.enableAudio = function(enabled) {
    easyRTC.audioEnabled = enabled;
};


/**
 *Sets whether video is transmitted by the local user in any subsequent calls.
 * @param {Boolean} enabled - true to include video, false to exclude video. The default is true.
 * @example
 *      easyRTC.enableVideo(false);
 */
easyRTC.enableVideo = function(enabled) {
    easyRTC.videoEnabled = enabled;
};


/**
 * Sets whether webrtc data channels are used to send inter-client messages.
 * This is only the messages that applications explicitly send to other applications, not the webrtc signalling messages.
 * @param {Boolean} enabled  true to use data channels, false otherwise. The default is false.
 * @example
 *     easyRTC.enableDataChannels(true);
 */
easyRTC.enableDataChannels = function(enabled) {
    easyRTC.dataEnabled = enabled;
}

/**
 * Returns a URL for your local camera and microphone.
 *  It can be called only after easyRTC.initMediaSource has succeeded.
 *  It returns a url that can be used as a source by the chrome video element or the &lt;canvas&gt; element.
 *  @return {URL}
 *  @example
 *      document.getElementById("myVideo").src = easyRTC.getLocalStreamAsUrl();
 */
easyRTC.getLocalStreamAsUrl = function() {
    if( easyRTC.localStream == null) {
        alert("Developer error: attempt to get a mediastream without invoking easyRTC.initMediaSource successfully");
    }
    return easyRTC.createObjectURL(easyRTC.localStream);
};


/**
  * Returns a media stream for your local camera and microphone.
  *  It can be called only after easyRTC.initMediaSource has succeeded.
  *  It returns a stream that can be used as an argument to easyRTC.setVideoObjectSrc.
  * @return {MediaStream}
  * @example
  *    easyRTC.setVideoObjectSrc( document.getElementById("myVideo"), easyRTC.getLocalStream());    
  */
easyRTC.getLocalStream = function() {
    return easyRTC.localStream;
};


/**
 *  Sets a video or audio object from a media stream.
 *  Chrome uses the src attribute and expects a URL, while firefox
 *  uses the mozSrcObject and expects a stream. This procedure hides
 *  that from you.
 *  @param {DOMObject} videoObject an HTML5 video object 
 *  @param {MediaStream} a media stream as returned by easyRTC.getLocalStream or your stream acceptor.
  * @example
  *    easyRTC.setVideoObjectSrc( document.getElementById("myVideo"), easyRTC.getLocalStream());    
 *     
 */
easyRTC.setVideoObjectSrc = function(videoObject, stream) {

    if( stream ) {
        videoObject.autoplay = true;
    }
    
    if( typeof videoObject.mozSrcObject != "undefined" ) {
        videoObject.mozSrcObject = (stream=="")?null:stream;
    }
    else {
        videoObject.src = (stream=="")?"":easyRTC.createObjectURL(stream);
    }
    if( stream ) {
        videoObject.play();
    }
};

/** @private */
easyRTC.formatError = function( x) {
    if( x === null || typeof x === 'undefined') {
        message = "null";
    }
    if( typeof x === 'string') {
        return x;
    }
    else if( x.type && x.description ) {
        return x.type + " : " + x.description;
    }
    else {
        return JSON.stringify(x);
    }    
}




/** Initializes your access to a local camera and microphone.
 *  Failure could be caused a browser that didn't support webrtc, or by the user
  * not granting permission.
  * If you are going to call easyRTC.enableAudio or easyRTC.enableVideo, you need to do it before
  * calling easyRTC.initMediaSource. 
  * @param {Function} successCallback - will be called when the media source is ready.
  * @param {Function} errorCallback - is called with a message string if the attempt to get media failed.
  * @example:
  *       easyRTC.initMediaSource(
  *          function() { 
  *              easyRTC.setVideoObjectSrc( document.getElementById("mirrorVideo"), easyRTC.getLocalStream()); 
  *          },
  *          function() {
  *               easyRTC.onError("Unable to get local media");
  *          });
  *          
  */
easyRTC.initMediaSource = function(successCallback, errorCallback) {
       
    if(easyRTC.debugPrinter) {
        easyRTC.debugPrinter("about to request local media");
    }
        
    if( errorCallback == null) {
        errorCallback = function(x) {
            var message = "easyRTC.initMediaSource: " + easyRTC.formatError(x);
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter(message);
            }
            alert(message);
        };
    }

    if( !successCallback) {
        alert("easyRTC.initMediaSource not supplied a successCallback");
        return;
    }

    /** @private */
    function callGetUserMedia(mode, successfunc, errorFunc) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("about to request local media = " + JSON.stringify(mode));
        }
        if( navigator.getUserMedia ) {
            navigator.getUserMedia(mode, successfunc, errorFunc);
        }
        else if( navigator.webkitGetUserMedia ) {
            navigator.webkitGetUserMedia(mode, successfunc, errorFunc);
        }
        else if( navigator.mozGetUserMedia ) {
            navigator.mozGetUserMedia(mode, successfunc, errorFunc);
        }
        else {
            errorCallback("Your browser doesn't appear to support WebRTC.");
        }
    }


    /** @private */
    var onUserMediaSuccess = function(stream) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("getUserMedia success callback entered");
        }
        if( easyRTC.audioEnabled && stream.getAudioTracks ) {
            var audioTracks = stream.getAudioTracks();
            if( !audioTracks || audioTracks.length == 0) {
                errorCallback("The application requested audio but the system didn't supply it");
                return;
            }
        }
        if( easyRTC.videoEnabled && stream.getVideoTracks ) {
            var videoTracks = stream.getVideoTracks();
            if( !videoTracks || videoTracks.length == 0) {
                errorCallback("The application requested video but the system didn't supply it");
                return;
            }
        }
        
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("successfully got local media");
        }
        easyRTC.localStream = stream;
        if( successCallback) {
            successCallback();
        }
        if( easyRTC.haveAudioVideo.video) {
            var videoObj = document.createElement('video');
            var triesLeft = 30;
            var tryToGetSize = function() {
                if( videoObj.videoWidth > 0|| triesLeft &lt; 0) {
                    easyRTC.nativeVideoWidth = videoObj.videoWidth;
                    easyRTC.nativeVideoHeight = videoObj.videoHeight;
                    easyRTC.updateConfigurationInfo();
                }
                else {
                    triesLeft -= 1;
                    setTimeout(tryToGetSize, 1000);
                }
            }
            tryToGetSize();
            easyRTC.setVideoObjectSrc(videoObj, stream);
        }
        else {
            easyRTC.updateConfigurationInfo();
        }
    };

    /** @private */
    var onUserMediaError = function(error) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("failed to get local media");
        }
        if( errorCallback ) {
            errorCallback("Failed to get access to local media. Error code was " + error.code + ".");
        }
        easyRTC.localStream = null;
        easyRTC.haveAudioVideo = {
            audio:false, 
            video: false
        };        
        easyRTC.updateConfigurationInfo();
    };


    if( !easyRTC.audioEnabled && !easyRTC.videoEnabled ) {
        onUserMediaError("At least one of audio and video must be provided");
        return;
    }
    
    /** @private */
    easyRTC.haveAudioVideo = {
        audio:easyRTC.audioEnabled,
        video: easyRTC.videoEnabled
    };
    
    
                          
    if( easyRTC.videoEnabled || easyRTC.audioEnabled) {
        try {
            callGetUserMedia({
                'audio': easyRTC.audioEnabled?true:false,
                'video': (easyRTC.videoEnabled)?(easyRTC.videoFeatures):false
            }, onUserMediaSuccess,
            onUserMediaError);
        } catch (e) {
            try {

                callGetUserMedia("video,audio", onUserMediaSuccess,
                    onUserMediaError);
            } catch (e) {
                document.body.removeChild(getUserMediaDiv);
                errorCallback("getUserMedia failed with exception: " + e.message);
            }
        }
    }
    else {
        onUserMediaSuccess(null);
    }
};


/**
 * easyRTC.setAcceptChecker sets the callback used to decide whether to accept or reject an incoming call.
 * @param {Function} acceptCheck takes the arguments (callerEasyrtcid, function():boolean ) {}
 * The acceptCheck callback is passed (as it's second argument) a function that should be called with either
 * a true value (accept the call) or false value( reject the call).
 * @example
 *      easyRTC.setAcceptChecker( function(easyrtcid, acceptor) {
 *           if( easyRTC.idToName(easyrtcid) === 'Fred' ) {
 *              acceptor(true);
 *           }
 *           else if( easyRTC.idToName(easyrtcid) === 'Barney' ) {
 *              setTimeout( function() {  acceptor(true)}, 10000);
 *           }
 *           else {
 *              acceptor(false);
 *           }
 *      });
 */
easyRTC.setAcceptChecker = function(acceptCheck) {
    easyRTC.acceptCheck = acceptCheck;
};


/**
  * easyRTC.setStreamAcceptor sets a callback to receive media streams from other peers, independent
  * of where the call was initiated (caller or callee).
 * @param {Function} acceptor takes arguments (caller, mediaStream)
 * @example
 *  easyRTC.setStreamAcceptor(function(easyrtcid, stream) {
 *     document.getElementById('callerName').innerHTML = easyRTC.idToName(easyrtcid);
 *     easyRTC.setVideoObjectSrc( document.getElementById("callerVideo"), stream); 
 *  });
 */
easyRTC.setStreamAcceptor = function(acceptor) {
    easyRTC.streamAcceptor = acceptor;
};


/** Sets the easyRTC.onError field to a user specified function.
 * @param {Function} errListener takes a error message string argument.
 * @example
 *    easyRTC.setOnError( function(message) {
 *        document.getElementById("errMessageDiv").innerHTML += message;
 *    });
 */
easyRTC.setOnError = function(errListener) {
    easyRTC.onError = errListener;
};


/**
  * Sets the callCancelled callback. This will be called when a remote user 
  * initiates a call to you, but does a "hangup" before you have a chance to get his video stream.
  * @param {Function} callCancelled takes an easyrtcid as an argument.
  * @example
  *     easyRTC.setCallCancelled( function(easyrtcid) {
  *         console..log(easyrtc.idToName(easyrtcid) + " stopped trying to reach you");
  *     });
 */
easyRTC.setCallCancelled = function( callCancelled) {
    easyRTC.callCancelled = callCancelled;
}

/**  Sets a callback to receive notification of a media stream closing. The usual
 *  use of this is to clear the source of your video object so you aren't left with 
 *  the last frame of the video displayed on it.
 *  @param {Function} onStreamClose takes an easyrtcid as it's first parameter.
 *  @example
 *     easyRTC.setOnStreamClosed( function(easyrtcid) {
 *         easyRTC.setVideoObjectSrc( document.getElementById("callerVideo"), "");
 *         console.log( easyRTC.idToName(easyrtcid) + " went away");
 *     });
 */
easyRTC.setOnStreamClosed = function(onStreamClosed) {
    easyRTC.onStreamClosed = onStreamClosed;
};


/**
  * Sets the bandwidth for sending video data.
  * Setting the rate too low will cause connection attempts to fail. 40 is probably good lower limit.
  * The default is 50. A value of zero will remove bandwidth limits.
  * @param {Number} rate in kilobits per second.
  * @example
  *    easyRTC.setVideoBandwidth( 40);
 */
easyRTC.setVideoBandwidth = function(kbitsPerSecond) {
    if(easyRTC.debugPrinter) {
        easyRTC.debugPrinter("video bandwidth set to " + kbitsPerSecond + " kbps");
    }
    if( kbitsPerSecond > 0 ) {
        easyRTC.videoBandwidthString = "b=AS:" + kbitsPerSecond;
    }
    else {
        easyRTC.videoBandwidthString = "";
    }
};


/**
 * Sets a listener for data sent from another client (either peer to peer or via websockets).
 * @param {Function} listener has the signature (easyrtcid, data)
 * @example
 *     easyRTC.setDataListener( function(easyrtcid, data) {
 *         console.log("From " + easyRTC.idToName(easyrtcid) + 
 *             " sent the follow data " + JSON.stringify(data));
 *     });
 */
easyRTC.setDataListener = function(listener) {
    easyRTC.receiveDataCB = listener;
};



/**
  * Sets the url of the Socket server.
  * The node.js server is great as a socket server, but it doesn't have
  * all the hooks you'd like in a general web server, like PHP or Python
  * plug-ins. By setting the serverPath your application can get it's regular
  * pages from a regular webserver, but the easyRTC library can still reach the
  * socket server.
  * @param {DOMString} socketUrl
  * @example
  *     easyRTC.setSocketUrl(":8080");
  */
easyRTC.setSocketUrl = function(socketUrl) {
    if(easyRTC.debugPrinter) {
        easyRTC.debugPrinter("webrtc signaling server URL set to " + socketUrl);
    }
    easyRTC.serverPath  = socketUrl;
}

/** 
 * Sets the user name associated with the connection.
 * @param {String} userName must obey standard identifier conventions.
 * @returns {Boolean} true if the call succeeded, false if the username was invalid.
 * @example
 *    if ( !easyRTC.setUserName("JohnSmith") ) {
 *        alert("bad user name);
 *    
 */
easyRTC.setUserName = function(userName) {
    if( easyRTC.isNameValid(userName)) {
        easyRTC.userName = userName;
        return true;
    }
    else {
        easyRTC.onError("Illegal username " + userName);
        return false;
    }
}

/**
 * Sets the listener for socket disconnection by external (to the API) reasons.
 * @param {Function} disconnectListener takes no arguments and is not called as a result of calling easyRTC.disconnect.
 * @example
 *    easyRTC.setDisconnectListener(function() {
 *        easyRTC.onError("Lost our connection to the socket server");
 *    });
 */ 
easyRTC.setDisconnectListener = function(disconnectListener) {
    easyRTC.disconnectListener = disconnectListener;
}



/**
  * Convert an easyrtcid to a user name. This is useful for labelling buttons and messages
  * regarding peers.
  * @param {String} easyrtcid
  * @return {String}
  * @example
  *    consolle.log(easyrtcid + " is actually " + easyRTC.idToName(easyrtcid));
  */
easyRTC.idToName = function(easyrtcid) {
    if( easyRTC.lastLoggedInList) {
        if( easyRTC.lastLoggedInList[easyrtcid] ) {
            if( easyRTC.lastLoggedInList[easyrtcid].userName) {
                return easyRTC.lastLoggedInList[easyrtcid].userName;
            }
            else {
                return easyrtcid;
            }
        }
    }
    return "--" + easyrtcid + "--";
}

/**
 * Connect to a easyRTC server. You must connect before trying to
* call other users. 
*  @param {String} applicationName is a string that identifies the application so that different applications can have different lists of users.
*  @param {Function} successCallback- is called with an easyrtcid on successful connect. 
*  @param {Function} errorCallback(msgString) - is called on unsuccessful connect. If null, an alert is called instead.
*  @example
*      easyRTC.connect('videoChat', 
*         function(easyrtcid) { 
*            console.log("Connected to the server, my id is " + easyrtcid);
*         },
*         function(errMessage) {
*            easyRTC.onError(errMessage);
*         });
*/
easyRTC.connect = function(applicationName, successCallback, errorCallback) {
    var channel = null;
    var servers = null;
    var pc_config = {};
    var me = "";
    var closedChannel = null;
    
    if(easyRTC.debugPrinter) {
        easyRTC.debugPrinter("attempt to connect to webrtc signalling server with application name=" + applicationName);
    }
    
    var mediaConstraints = {
        'mandatory': {
            'OfferToReceiveAudio':true,
            'OfferToReceiveVideo':true
        },
        'optional': [{
            RtpDataChannels: easyRTC.dataEnabled
        }]
    };

    //
    // easyRTC.disconnect performs a clean disconnection of the client from the server.
    //
    easyRTC.disconnect = function() {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("attempt to disconnect from webrtc signalling server");
        }


        easyRTC.disconnecting = true;
        easyRTC.hangupAll();
        easyRTC.loggingOut = true;
        // 
        // The hangupAll may try to send configuration information back to the server.
        // Collecting that information is asynchronous, we don't actually close the 
        // connection until it's had a chance to be sent. We allocate 100ms for collecting
        // the info, so 250ms should be sufficient for the disconnecting.
        // 
        setTimeout( function() {
            if(channel) {
                channel.disconnect();
                closedChannel = channel;
                channel = 0;
                
            }
            easyRTC.loggingOut = false;
            easyRTC.disconnecting = false;
            if( easyRTC.loggedInListener) {
                easyRTC.loggedInListener({});
            }
            oldConfig = {}
        }, 250);
    };


    if( errorCallback == null) {
        errorCallback = function(x) {
            alert("easyRTC.connect: " + x);
        };
    }

    var sendMessage = function(destUser, instruction, data, successCallback, errorCallback){

        if( !channel ) {
            throw "Attempt to send message without a valid connection to the server."
        }
        else {
            var dataToShip = {
                msgType:instruction,
                senderId: me,
                targetId: destUser,
                msgData:{
                    from:me,
                    type:instruction,
                    actualData:data
                }
            }
            
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter("sending socket message " + JSON.stringify(dataToShip));
            }
            channel.json.emit("easyRTCcmd", dataToShip);
        }
    };



    /**
     *Sends data to another user using previously established data channel. This method will
     * fail if no data channel has been established yet. Unlike the easyRTC.sendWS method, 
     * you can't send a dictionary, convert dictionaries to strings using JSON.stringify first. 
     * What datatypes you can send, and how large a datatype depends on your browser.
     * @param {String} destEasyrtcid
     * @param {Object} data - an object which can be JSON'ed.
     * @example
     *     easyRTC.sendDataP2P(someEasyrtcid, {room:499, bldgNum:'asd'});
     */
    easyRTC.sendDataP2P = function(destUser, data) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("sending p2p message to " + destUser + " with data=" + JSON.stringify(data));
        }
        //        if( easyRTC.peerConns[destUser] && easyRTC.peerConns[destUser].dataChannelReady) {
        if(  easyRTC.peerConns[destUser] && easyRTC.peerConns[destUser].dataChannel ) {
            easyRTC.peerConns[destUser].dataChannel.send(data);
        }
        else {
            easyRTC.onError("Attempt to send data peer to peer without establishing a connection to " + destUser + ' first.');
        }
    }



    /** Sends data to another user using websockets.
      * @param {String} destEasyrtcid
      * @param {String} data - an object which can be JSON'ed.
      * @example 
      *    easyRTC.sendDataWS(someEasyrtcid, {room:499, bldgNum:'asd'});
     */
    easyRTC.sendDataWS = function(destUser, data) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("sending client message via websockets to " + destUser + " with data=" + JSON.stringify(data));
        }
        if( channel ) {
            channel.json.emit("message", {
                senderId:me,
                targetId: destUser,
                msgData:data
            });
        }
        else {
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter("websocket failed because no connection to server");
            }
            throw "Attempt to send message without a valid connection to the server.";
        }
    }
    
    
    /** Sends data to another user. This method uses datachannels if one has been set up, or websockets otherwise.
      * @param {String} senderId
      * @param {String} data - an object which can be JSON'ed.
      * @example 
      *    easyRTC.sendData(someEasyrtcid, {room:499, bldgNum:'asd'});
      */
    easyRTC.sendData = function(destUser, data ) {
        if( easyRTC.peerConns[destUser] && easyRTC.peerConns[destUser].dataChannelReady) {
            easyRTC.sendDataP2P( destUser, data);
        }
        else {
            easyRTC.sendDataWS( destUser, data);
        }
    };



    /** Value returned by easyRTC.getConnectStatus if the other user isn't connected. */
    easyRTC.NOT_CONNECTED = "not connected";
    
    /** Value returned by easyRTC.getConnectStatus if the other user is in the process of getting connected */
    easyRTC.BECOMING_CONNECTED = "connection in progress";
    
    /** Value returned by easyRTC.getConnectStatus if the other user is connected. */
    easyRTC.IS_CONNECTED = "is connected";

    /**
     * Return true if the client has a peer-2-peer connection to another user.
     * The return values are text strings so you can use them in debugging output.
     *  @param {String} otherUser - the easyrtcid of the other user.
     *  @return {String} one of the following values: easyRTC.NOT_CONNECTED, easyRTC.BECOMING_CONNECTED, easyRTC.IS_CONNECTED
     *  @example
     *     if( easyRTC.getConnectStatus(otherEasyrtcid) == easyRTC.NOT_CONNECTED ) {
     *         easyRTC.connect(otherEasyrtcid, 
     *                  function() { console.log("success"); },
     *                  function() { console.log("failure"); });
     *     }
     */    
    easyRTC.getConnectStatus = function(otherUser){
        if( typeof easyRTC.peerConns[otherUser] == 'undefined' ) {
            return easyRTC.NOT_CONNECTED;
        }
        var peer = easyRTC.peerConns[otherUser];
        if( (peer.sharingAudio || peer.sharingVideo) && !peer.startedAV) {
            return easyRTC.BECOMING_CONNECTED;            
        }
        else if( peer.sharingData && !peer.dataChannelReady) {
            return easyRTC.BECOMING_CONNECTED;            
        }    
        else {
            return easyRTC.IS_CONNECTED;
        }
    }




            
    


    /** Initiates a call to another user. If it succeeds, the streamAcceptor callback will be called.
     * @param {String} otherUser - the easyrtcid of the peer being called.
     * @param {Function} callSuccessCB(otherCaller, mediaType) - is called when the datachannel is established or the mediastream is established. mediaType will have a value of "audiovideo" or "datachannel"
     * @param {Function} callFailureCB(errMessage) - is called if there was a system error interfering with the call.
     * @param {Function} wasAcceptedCB(wasAccepted:boolean,otherUser:string) - is called when a call is accepted or rejected by another party. It can be left null.
     * @example:
     *    easyRTC.call( otherEasyrtcid, 
     *        function(easyrtcid, mediaType) {
     *           console.log("Got mediatype " + mediaType + " from " + easyRTC.idToName(easyrtcid);
     *        },
     *        function(easyrtcid, mediaType) {
     *           console.log("call to  " + easyRTC.idToName(easyrtcid) + " failed");
     *        },
     *        function(wasAccepted, easyrtcid) {
     *            if( wasAccepted ) {
     *               console.log("call accepted by " + easyRTC.idToName(easyrtcid));
     *            }
     *            else {
     *                console.log("call rejected" + easyRTC.idToName(easyrtcid));
     *            }
     *        });
     *        
     *        
     */
    easyRTC.call = function(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("initiating peer to peer call to " + otherUser + 
                " audio=" + easyRTC.audioEnabled + 
                " video=" + easyRTC.videoEnabled + 
                " data=" + easyRTC.dataEnabled );
        }
        
        //
        // If we are sharing audio/video and we haven't allocated the local media stream yet,
        // we'll do so, recalling ourself on success.
        //
        if( easyRTC.localStream == null && (easyRTC.audioEnabled || easyRTC.videoEnabled)) {
            easyRTC.initMediaSource(function() {
                easyRTC.call(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB);
            }, callFailureCB);
            return;
        }

        if( !channel) {
            var message = "Attempt to make a call prior to connecting to service";
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter(message);
            }
            throw message;
        }
        
        //
        // Mozilla currently requires a media stream to set up data channels.
        // The below code attempts to create a fake data stream if a real data stream isn't being shared.
        // After the fake stream is created, the callback relaunches the easyRTC.call with the original
        // arguments.
        //
        if( navigator.mozGetUserMedia && easyRTC.dataEnabled && easyRTC.videoEnabled == false 
            && easyRTC.audioEnabled == false && easyRTC.mozFakeStream == null ) {
            navigator.mozGetUserMedia({
                audio:true, 
                fake:true
            }, function(s) {
                if( !s) {
                    var message = "Error getting fake media stream for Firefox datachannels: null stream";
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter(message);
                    }
                    callFailureCB(message);
                }
                easyRTC.mozFakeStream = s;
                easyRTC.call( otherUser, callSuccessCB, callFailureCB, wasAcceptedCB);
            }, function(err) {
                var message = "Error getting fake media stream for Firefox datachannels: " + err;
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter(message);
                }   
                callFailureCB(message);
            }); 
            return;
        }
        
        
        // do we already have a pending call?
        if( typeof easyRTC.acceptancePending[otherUser] !== 'undefined' ) {
            message = "Call already pending acceptance";
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter(message);
            }
            callFailureCB(message);
            return;
        }

        easyRTC.acceptancePending[otherUser] = true;
        
        var pc = buildPeerConnection(otherUser, true, callFailureCB);
        if( !pc ) {
            message = "buildPeerConnection failed, call not completed";
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter(message);
            }
            return;
        }
        easyRTC.peerConns[otherUser].callSuccessCB = callSuccessCB;
        easyRTC.peerConns[otherUser].callFailureCB = callFailureCB;
        easyRTC.peerConns[otherUser].wasAcceptedCB = wasAcceptedCB;
        
        var peerConnObj = easyRTC.peerConns[otherUser];

        var setLocalAndSendMessage = function(sessionDescription) {
            if( peerConnObj.cancelled) return;
            var sendOffer = function(successCB, errorCB) {
                sendMessage(otherUser, "offer", sessionDescription, successCB, callFailureCB);
            }

            pc.setLocalDescription(sessionDescription, sendOffer, callFailureCB);
        };

        pc.createOffer(setLocalAndSendMessage, null, mediaConstraints);
    };


    
    function limitBandWidth(sd) {
        if( easyRTC.videoBandwidthString != "" ) {
            var pieces = sd.sdp.split('\n');
            for(var i = pieces.length -1; i >= 0; i-- ) {
                if( pieces[i].indexOf("m=video") == 0 ) {
                    for(var j = i;  j &lt; i+10 && pieces[j].indexOf("a=") == -1 &&
                        pieces[j].indexOf("k=") == -1; j++ ) {
                    }
                    pieces.splice(j, 0, (easyRTC.videoBandwidthString + "\r"));
                }
            }
            sd.sdp = pieces.join("\n");
        }
    };


    function hangupBody(otherUser) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("Hanging up on " + otherUser);
        }
        clearQueuedMessages(otherUser);
        if( easyRTC.peerConns[otherUser] ) {
            if( easyRTC.peerConns[otherUser].startedAV ) {
                try {
                    easyRTC.peerConns[otherUser].pc.close();
                } catch(ignoredError) {}
                
                if( easyRTC.onStreamClosed ) {
                    easyRTC.onStreamClosed(otherUser);
                }
            }
            
            easyRTC.peerConns[otherUser].cancelled = true;
            
            delete easyRTC.peerConns[otherUser];
            if( channel) {
                sendMessage(otherUser, "hangup", {}, function() {
                    }, function(msg) {
                        if( easyRTC.debugPrinter) { 
                            debugPrinter("hangup failed:" + msg);
                        }
                    });
            }
            if( easyRTC.acceptancePending[otherUser]) {
                delete easyRTC.acceptancePending[otherUser];
            }
        }        
    }
    
    /**
      * Hang up on a particular user or all users.
      *  @param {String} easyrtcid - the easyrtcid of the person to hang up on.
      *  @example
      *     easyRTC.hangup(someEasyrtcid);
      */
    easyRTC.hangup = function(easyrtcid) {
        hangupBody(easyrtcid);
        easyRTC.updateConfigurationInfo();
    };


    /**
      * Hangs up on all current connections.
      * @example
      *    easyRTC.hangupAll();
      */
    easyRTC.hangupAll = function() {
        var sawAConnection = false;
        for( otherUser in easyRTC.peerConns ) {
            sawAConnection = true;
            hangupBody(otherUser);
            if( channel) {
                sendMessage(otherUser, "hangup", {}, function() {
                    }, function(msg) {
                        if( easyRTC.debugPrinter) {
                            easyRTC.debugPrinter("hangup failed:" + msg);
                        }
                    });                
            }            
        }       
        if( sawAConnection) {
            easyRTC.updateConfigurationInfo();
        }
    };


    var createRTCPeerConnection = function(pc_config, optionalStuff) {

        if( window.mozRTCPeerConnection) {
            return new mozRTCPeerConnection(pc_config, optionalStuff);
        }
        else if (window.webkitRTCPeerConnection) {
            return new webkitRTCPeerConnection(pc_config, optionalStuff);
        }
        else if( window.RTCPeerConnection) {
            return new RTCPeerConnection(pc_config, optionalStuff);
        }
        else {
            throw "Your browser doesn't support webRTC (RTCPeerConnection)";
        }
    };



    var buildPeerConnection = function(otherUser, isInitiator, failureCB) {
        var pc;
        var message;
        
        var optionalStuff = null;
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("building peer connection to " + otherUser);
        }
        
        if( easyRTC.dataEnabled) {
            optionalStuff = {
                optional: [{
                    RtpDataChannels: true
                }]
            }            
        }
        
        try {
            pc = createRTCPeerConnection(pc_config, optionalStuff);
            
            if( !pc) {
                message = "Unable to create PeerConnection object, check your ice configuration(" + 
                JSON.stringify(pc_config) + ")";
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter(message);
                }                
                throw(message);
            }

            //
            // turn off data channel support if the browser doesn't support it.
            //
            if( easyRTC.dataEnabled && typeof pc.createDataChannel == 'undefined') {
                easyRTC.dataEnabled = false;
            }



            pc.onconnection = function() {
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("onconnection called prematurely");
                }                
            }
            var newPeerConn = {
                pc:pc,
                candidatesToSend:[],
                startedAV: false,
                isInitiator: isInitiator
                 
            };

            pc.onicecandidate = function(event) {
                if( easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("saw ice message:\n" + event.candidate);
                }
                if( newPeerConn.cancelled) return;
                if (event.candidate && easyRTC.peerConns[otherUser]) {
                    var candidateData = {
                        type: 'candidate',
                        label: event.candidate.sdpMLineIndex,
                        id: event.candidate.sdpMid,
                        candidate: event.candidate.candidate
                    };
                    if( easyRTC.peerConns[otherUser].startedAV ) {
                        sendMessage(otherUser, "candidate",candidateData);
                    }
                    else {
                        easyRTC.peerConns[otherUser].candidatesToSend.push(candidateData);
                    }
                }
            }

            pc.onaddstream = function(event) {
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("saw incoming media stream");
                }                
                if( newPeerConn.cancelled) return;
                easyRTC.peerConns[otherUser].startedAV = true;
                easyRTC.peerConns[otherUser].sharingAudio = easyRTC.haveAudioVideo.audio;
                easyRTC.peerConns[otherUser].sharingVideo = easyRTC.haveAudioVideo.video;
                easyRTC.peerConns[otherUser].connectTime = new Date().getTime();

                if( easyRTC.peerConns[otherUser].callSuccessCB ) {
                    if( easyRTC.peerConns[otherUser].sharingAudio || easyRTC.peerConns[otherUser].sharingVideo ) {
                        easyRTC.peerConns[otherUser].callSuccessCB(otherUser, "audiovideo");
                    }
                }
                if( easyRTC.audioEnabled || easyRTC.videoEnabled) { // might be a fake audio stream for mozilla data channels
                    updateConfiguration();
                }
                if( easyRTC.streamAcceptor ) {
                    easyRTC.streamAcceptor(otherUser, event.stream);
                }
            }
            
            pc.onremovestream = function(event) {
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("saw remove on remote media stream");
                }                

                if( easyRTC.peerConns[otherUser] ) {
                    if( easyRTC.onStreamClosed ) {
                        easyRTC.onStreamClosed(otherUser);
                    }
                    delete easyRTC.peerConns[otherUser];
                    easyRTC.updateConfigurationInfo();
                }
            }
            easyRTC.peerConns[otherUser] = newPeerConn;
            
        } catch (e) {
            if( easyRTC.debugPrinter) {
                easyRTC.debugPrinter(JSON.stringify(e));
            }
            failureCB(e.message);
            return null;
        }
        
        if( easyRTC.videoEnabled || easyRTC.audioEnabled) {
            if( easyRTC.localStream == null) {
                message = "Application program error: attempt to share audio or video before calling easyRTC.initMediaSource."
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter(message);
                }
                alert(message)
            }
            else {
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("adding local media stream to peer connection");
                }
                pc.addStream(easyRTC.localStream);
            }
        }
        else if( easyRTC.dataEnabled && navigator.mozGetUserMedia) { // mozilla needs a fake data stream for channels currently.
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter("added fake stream to peer connection");
            }
            pc.addStream(easyRTC.mozFakeStream);
        }
        
        if( easyRTC.dataEnabled ) {
           
            function setupDataChannel(dataChannel) {
                
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("saw setupDataChannel call");
                }
                easyRTC.peerConns[otherUser].dataChannel = dataChannel;
                
                //channel.binaryType = "blob";
                
                dataChannel.onmessage = function(event) {
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("saw channel.onmessage event");
                    }
                    if( easyRTC.receiveDataCB ) {
                        easyRTC.receiveDataCB(otherUser, event.data);
                    }                    
                };
                
                dataChannel.onopen = function(event) {
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("saw channel.onopen event");
                    }
                    if(easyRTC.peerConns[otherUser]) {
                        easyRTC.peerConns[otherUser].dataChannelReady = true;                        
                    
                        if( easyRTC.peerConns[otherUser].callSuccessCB ) {
                            easyRTC.peerConns[otherUser].callSuccessCB(otherUser, "datachannel");
                        }
                        if( easyRTC.onDataChannelOpen ) {
                            easyRTC.onDataChannelOpen(otherUser);
                        }
                        easyRTC.updateConfigurationInfo();
                    }
                };
                
                dataChannel.onclose = function(event) {
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("saw channel.onclose event");
                    }
                    if(easyRTC.peerConns[otherUser]) {
                        easyRTC.peerConns[otherUser].dataChannelReady = false;
                        delete easyRTC.peerConns[otherUser].dataChannel;
                    }
                    if( easyRTC.onDataChannelClose ) {
                        easyRTC.onDataChannelClose(openUser);
                    }

                    easyRTC.updateConfigurationInfo();
                };
            }
            

            if(isInitiator) {
                function initiateDataChannel() {
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("called initiateDataChannel");                        
                    }
                    try {
                        var dataChannel = pc.createDataChannel(easyRTC.datachannelName, easyRTC.datachannelConstraints);            
                        setupDataChannel(dataChannel);                
                    } catch(channelErrorEvent) {
                        failureCB( JSON.stringify(channelErrorEvent));
                    }                    
                }
                
                if( navigator.mozGetUserMedia ) {
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("setup pc.onconnection callback for initiator");
                    }
                    pc.onconnection = initiateDataChannel;
                }
                else {
                    initiateDataChannel();
                }
            }
            else {
                pc.onconnection = function(){
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("callee onconnection event seen");
                    }
                };
                pc.ondatachannel = function(event) {
                    // Chrome passes down an event with channel attribute,
                    // whereas Mozilla passes down the channel itself.
                    if( event.channel) {
                        setupChannel(event.channel);
                    }
                    else {
                        setupChannel(event);
                    }
                    if(easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("received data channel");
                    }
                    easyRTC.peerConns[otherUser].dataChannelReady = true;
                };
            }
        }
        return pc;
    };


    var doAnswer = function(caller, msg) {
        
        if( easyRTC.dataEnabled && !easyRTC.videoEnabled && !easyRTC.audioEnabled 
            && navigator.mozGetUserMedia && easyRTC.mozFakeStream == null ) {
            navigator.mozGetUserMedia({
                audio:true, 
                fake:true
            }, function(s) {
                if( !s) {
                    callFailureCB("Error getting fake media stream for Firefox datachannels: null stream");
                }
                easyRTC.mozFakeStream = s;
                doAnswer(caller, msg);
            }, function(err) {
                callFailureCB("Error getting fake media stream for Firefox datachannels: " + err);
            });   
            return;
        }
        var pc = buildPeerConnection(caller, false, easyRTC.onError);
        
        var newPeerConn = easyRTC.peerConns[caller];
        
        if( !pc) {
            if(easyRTC.debugPrinter) {
                easyRTC.debugPrinter("buildPeerConnection failed. Call not answered");
            }
            return;
        }
        var setLocalAndSendMessage = function(sessionDescription) {
            if( newPeerConn.cancelled) return;
            
            var sendAnswer = function() {
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("sending answer");
                }
                sendMessage(caller, "answer", sessionDescription, function() {}, easyRTC.onError);
                easyRTC.peerConns[caller].startedAV = true;
                if( pc.connectDataConnection) {
                    if( easyRTC.debugPrinter) {
                        easyRTC.debugPrinter("calling connectDataConnection(5002,5001)");
                    }
                    pc.connectDataConnection(5002,5001); 
                }
            };
            pc.setLocalDescription(sessionDescription, sendAnswer, easyRTC.onError);

        };
        var sd = null;

        if( window.mozRTCSessionDescription ) {
            sd = msg.actualData;
        }
        else {
            sd = new RTCSessionDescription(msg.actualData);
        }
        var invokeCreateAnswer = function() {
            if( newPeerConn.cancelled) return;
            pc.createAnswer(setLocalAndSendMessage, easyRTC.onError, mediaConstraints);
        };
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("about to call setRemoteDescription in doAnswer");            
        }
        try {
            //    limitBandWidth(sd);
            pc.setRemoteDescription(sd, invokeCreateAnswer, easyRTC.onError);
        } catch(srdError ) {
            if( easyRTC.debugPrinter) {
                easyRTC.debugPrinter("saw exception in setRemoteDescription");
            }
            easyRTC.onError("setRemoteDescription failed: " + srdError.message);
        }
    };

    /** @private */
    easyRTC.onRemoteHangup = function(caller) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("Saw onremote hangup event");
        }
        if( easyRTC.peerConns[caller]) {
            easyRTC.peerConns[caller].cancelled = true;
            if( easyRTC.peerConns[caller].startedAV) {
                if(  easyRTC.onStreamClosed  ) {
                    easyRTC.onStreamClosed(caller);
                }
            }
            else {
                if(easyRTC.callCancelled ){
                    easyRTC.callCancelled(caller);
                }                
            }
            try {
                easyRTC.peerConns[caller].pc.close();
            } catch( anyErrors) {
            };
            delete easyRTC.peerConns[caller];
            easyRTC.updateConfigurationInfo();
        }
        else {
            if(easyRTC.callCancelled ){
                easyRTC.callCancelled(caller);
            }                            
        }
    };


    //
    // The app engine has many machines running in parallel. This means when
    //  a client sends a sequence of messages to another client via the server,
    //  one at a time, they don't necessarily arrive in the same order in which
    // they were sent. In particular, candidates arriving before an offer can throw
    // a wrench in the gears. So we queue the messages up until we are ready for them.
    //
    var queuedMessages = {};

    var clearQueuedMessages = function(caller ) {
        queuedMessages[caller] = {
            candidates:[]
        };
    };


    var onChannelMessage = function(msg) {

        if( easyRTC.receiveDataCB ) {
            easyRTC.receiveDataCB(msg.senderId, msg.msgData);
        }
    };




    var onChannelCmd = function(msg) {
        
        var caller = msg.senderId;
        var msgType = msg.msgType;
        var actualData = msg.msgData;
        var pc;

        if( easyRTC.debugPrinter) {
            easyRTC.debugPrinter('received message of type ' + msgType);
        }

        if( typeof queuedMessages[caller] == "undefined" ) {
            clearQueuedMessages(caller);
        }

        var processConnectedList = function(connectedList) {
            for(var i in easyRTC.peerConns) {
                if( typeof connectedList[i] == 'undefined' ) {
                    if( easyRTC.peerConns[i].startedAV ) {
                        easyRTC.onRemoteHangup(i);
                        clearQueuedMessages(i);
                    }
                }
            }
        };


        var processCandidate = function(actualData) {
            var candidate = null;
            if( window.mozRTCIceCandidate ) {
                candidate = new mozRTCIceCandidate({
                    sdpMLineIndex:actualData.label,
                    candidate:actualData.candidate
                });
            }
            else {
                candidate = new RTCIceCandidate({
                    sdpMLineIndex:actualData.label,
                    candidate:actualData.candidate
                });
            }
            pc = easyRTC.peerConns[caller].pc;
            pc.addIceCandidate(candidate);
        };


        var flushCachedCandidates = function(caller) {
            if( queuedMessages[caller] ) {
                for(var i = 0; i &lt; queuedMessages[caller].candidates.length; i++ ) {
                    processCandidate(queuedMessages[caller].candidates[i]);
                }
                delete queuedMessages[caller];
            }
        };


        var processOffer = function(caller, actualData) {

            var helper = function(wasAccepted) {
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("offer accept=" + wasAccepted);
                }
                
                if( wasAccepted) {
                    //
                    // at the point at which an offer is accepted, we may not have grabbed the 
                    // local media stream yet. So we grab it at this point and recall ourself as needed.
                    //
                    if( easyRTC.localStream == null && (easyRTC.audioEnabled || easyRTC.videoEnabled)) {
                        easyRTC.initMediaSource(function() {
                            helper(true);
                        }, function(){
                            if(easyRTC.debugPrinter) {
                                easyRTC.debugPrinter("offer rejected because no media available");
                            }                            
                            helper(false);
                        });
                        return;
                    }
                    doAnswer(caller, actualData);
                    flushCachedCandidates(caller);
                }
                else {
                    sendMessage(caller, "reject", {}, function() {}, function() {});
                    clearQueuedMessages(caller);
                }
            }

            if( !easyRTC.acceptCheck ) {
                helper(true);
            }
            else {
                easyRTC.acceptCheck(caller, helper);
            }
        };


        switch(msgType) {
            
            case 'error':
                easyRTC.onError(actualData.errorCode + ': ' + actualData.errorText); 
                // the below is purely for the orlando show.
                //if(actualData.errorCode == "MSG_REJECT_NO_AUTH") {
                //    setTimeout(function(){
                //         window.location.reload();
                //     }, 2000);
                //  }
                break;
                
            case 'token':
                if(easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("Saw token of " + msg.easyrtcid);
                }
                me = msg.easyrtcid;
                pc_config = msg.iceConfig;
            
                if( successCallback) {
                    successCallback(me);
                }
                break;
                
            case 'updateInfo':
                easyRTC.updateConfigurationInfo();
                break;
                
            case 'list':
                //
                // The below check can be removed once we have server side code to 
                // avoid getting multiple downloads of the list when a new person hooks up.
                //
                if( actualData.connections[me] &&
                    actualData.connections[me].applicationName &&
                    actualData.connections[me].applicationName != applicationName) {
                    return;
                }
                if( easyRTC.debugPrinter) {
                    easyRTC.debugPrinter("incoming list was " + JSON.stringify(actualData.connections));
                }
                delete actualData.connections[me];
                easyRTC.lastLoggedInList = actualData.connections;
                processConnectedList(actualData.connections);
                if( easyRTC.loggedInListener ) {
                    easyRTC.loggedInListener(actualData.connections);
                }
                break;
                
            case 'offer':
                processOffer(caller, actualData);
                break;
                
            case 'reject':
                delete easyRTC.acceptancePending[caller];
                if( queuedMessages[caller] ) {
                    delete queuedMessages[caller];
                }
                if( easyRTC.peerConns[caller]) {
                    if( easyRTC.peerConns[caller].wasAcceptedCB ) {
                        easyRTC.peerConns[caller].wasAcceptedCB(false, caller);
                    }
                    delete easyRTC.peerConns[caller];
                }
                break;
                
            case 'answer':
                delete easyRTC.acceptancePending[caller];
                if( easyRTC.peerConns[caller].wasAcceptedCB ) {
                    easyRTC.peerConns[caller].wasAcceptedCB(true, caller);
                }
                for(var i = 0; i &lt; easyRTC.peerConns[caller].candidatesToSend.length ; i++ ) {
                    sendMessage(caller, "candidate",easyRTC.peerConns[caller].candidatesToSend[i]);
                }

                pc = easyRTC.peerConns[caller].pc;
                var sd = null;
                if( window.mozRTCSessionDescription ) {
                    sd = new mozRTCSessionDescription(actualData.actualData);
                }
                else {
                    sd = new RTCSessionDescription(actualData.actualData);
                }
                if( !sd ) {
                    throw "Could not create the RTCSessionDescription";
                }
                //            limitBandWidth(sd);
                if( easyRTC.debugPrinter ) {
                    easyRTC.debugPrinter("about to call initiating setRemoteDescription");
                }
                pc.setRemoteDescription(sd, function() {
                    if( pc.connectDataConnection ) {
                        if( easyRTC.debugPrinter) {
                            easyRTC.debugPrinter("calling connectDataConnection(5001,5002)");
                        }
                        pc.connectDataConnection(5001,5002); // these are like ids for data channels
                    }
                });
                flushCachedCandidates(caller);
                break;
                
            case 'candidate':
                if( easyRTC.peerConns[caller] && easyRTC.peerConns[caller].startedAV ) {
                    processCandidate(actualData.actualData);
                }
                else {
                    if( !easyRTC.peerConns[caller] ) {
                        queuedMessages[caller] = {
                            candidates:[]
                        };
                    }
                    queuedMessages[caller].candidates.push(actualData.actualData);
                }
                break;
                
            case 'hangup':
                easyRTC.onRemoteHangup(caller);
                clearQueuedMessages(caller);
                break;
        }
    };


    var onChannelError = function() {
        if( easyRTC.debugPrinter) {
            easyRTC.debugPrinter("saw channel error");
        }
        easyRTC.onError("Saw channel error.");
    }


    if( !window.io ) {
        easyRTC.onError("Your HTML has not included the socket.io.js library");
    }


    channel = io.connect(easyRTC.serverPath, {
        'force new connection':true
    });
    if( !channel) {
        throw "io.connect failed";
    }
    channel.on("message", onChannelMessage);
    channel.on("easyRTCcmd", onChannelCmd);  // deprecated
    channel.on("easyrtcCmd", onChannelCmd);
    channel.on("disconnect", function(code, reason, wasClean) {
        easyRTC.updateConfigurationInfo = function() {};        
        if( !easyRTC.disconnecting ) {
            easyRTC.disconnect();
            if( easyRTC.disconnectListener ) {
                easyRTC.disconnectListener();
            }
        }
    });

    function  getStatistics(pc, track, results) {
        var successcb = function(stats) {
            for(var i in stats) {
                results[i] = stats[i];
            }
        }
        var failurecb = function(event) {
            results.error = event;
        }
        pc.getStats(track, successcb, failurecb);
    }


    function DeltaRecord(added, deleted, modified) {
        function objectNotEmpty(obj) {
            for(var i in obj) {
                return true;
            }
            return false;
        }
        
        var result = {};
        if( objectNotEmpty(added)) {
            result.added = added;
        }
            
        if( objectNotEmpty(deleted)) {
            result.deleted = deleted;
        }
                    
        if( objectNotEmpty(result)) {
            return result;
        }
        else {
            return null;
        }        
    }
    
    function findDeltas(oldVersion, newVersion) {
        var i;
        var added = {}, deleted = {};
        
        for( i in newVersion) {
            if( oldVersion == null || typeof oldVersion[i] == 'undefined') {
                added[i] = newVersion[i];
            }
            else if( typeof newVersion[i] == 'object') {
                var subPart = findDeltas(oldVersion[i], newVersion[i]);
                if( subPart != null ) {
                    added[i] = newVersion[i];
                }
            }
            else if( newVersion[i] != oldVersion[i]) {
                added[i] = newVersion[i];

            }
        }
        for( i in oldVersion) {
            if( typeof newVersion[i] == 'undefined') {
                deleted = oldVersion[i];
            }
        }
        
        return  new DeltaRecord(added, deleted);
    }
    
    var oldConfig = {}; // used internally by updateConfiguration
    
    var updaterCount = 0;
    
    function updateConfiguration() {
        var connectionList = {};
        for(var i in easyRTC.peerConns ) {
            connectionList[i] = {
                connectTime: easyRTC.peerConns[i].connectTime,
                sharingAudio: easyRTC.peerConns[i].sharingAudio?true:false,
                sharingVideo: easyRTC.peerConns[i].sharingVideo?true:false,
                sharingData: easyRTC.peerConns[i].dataChannel?true:false,
                isInitiator: easyRTC.peerConns[i].isInitiator?true:false
            };

            if( easyRTC.peerConns[i].pc.getStats) {
                var pc = easyRTC.peerConns[i].pc;
                pc.getStats( function(dest) {                    
                    return function(stats) {  
                        if( stats === {}) {
                            dest.stats = "none";
                        }
                        else {
                            dest.stats = stats.result();
                        }
                    }                    
                }( connectionList[i]));                
            }
        }
                
        var newConfig = {
            apiVersion: easyRTC.apiVersion,
            sharingAudio: easyRTC.haveAudioVideo.audio?true:false,
            sharingVideo: easyRTC.haveAudioVideo.video?true:false,
            sharingData: easyRTC.dataEnabled?true:false,
            nativeVideoWidth: easyRTC.nativeVideoWidth,
            nativeVideoHeight: easyRTC.nativeVideoHeight,
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight,
            connectionList: connectionList,
            apiKey: easyRTC.apiKey,
            applicationName: applicationName,
            screenWidth: window.screen.width,
            screenHeight: window.screen.height,
            cookieEnabled: navigator.cookieEnabled,
            os: navigator.oscpu
        };
        if( easyRTC.userName ) {
            newConfig.userName = easyRTC.userName;
        }
        //
        // we need to give the getStats calls a chance to fish out the data. 
        // The longest I've seen it take is 5 milliseconds so 100 should be overkill.
        //
        setTimeout( function() {
        
            var alteredData = findDeltas(oldConfig, newConfig);
            
            //
            // send all the configuration information that changes during the session
            //
            if( easyRTC.debugPrinter) {
                easyRTC.debugPrinter("cfg=" + JSON.stringify(alteredData.added));
            }
            
            if( channel ) {
                channel.json.emit("easyRTCcmd",
                {
                    msgType:'setUserCfg',
                    msgData: alteredData.added
                }
                );
            }
            oldConfig = newConfig;
        }, 100);
    }
    
    
    channel.on("connect", function(event) {
        if( !channel ) {
            channel = closedChannel;
        }
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("saw socketserver onconnect event");
        }
        if( channel) {            
            easyRTC.updateConfigurationInfo = updateConfiguration;
            updateConfiguration();
        }
        else {
            errorCallback("Internal communications failure.")
        }
    }
    );
}

/**
* Provides a layer on top of the easyRTC.initMediaSource and easyRTC.connect, assign the local media stream to
* the video object identified by monitorVideoId, assign remote video streams to
* the video objects identified by videoIds, and then call onReady. One of it's
* side effects is to add refresh and stop buttons to the remote video objects, buttons
* that only appear when you hover over them with the mouse cursor.
*  @param {String} applicationName - name of the application.
*  @param {String} monitorVideoId - the id of the video object used for monitoring the local stream.
*  @param {Array} videoIds - an array of video object ids (strings)
*  @param {Function} onReady - a callback function used on success. On failure, an alert is thrown.
*  @example:
*     easyRTC.initManaged('multiChat', 'selfVideo', ['remote1', 'remote2', 'remote3'], 
*              function() {
*                  console.log("successfully connected.");
*              });
*/
easyRTC.initManaged = function(applicationName, monitorVideoId, videoIds, onReady) {
    var numPEOPLE = videoIds.length;
    var refreshPane = 0;
    var onCall = null, onHangup = null;
    
    if( videoIds == null) {
        videoIds = [];
    }
    
    
    /** Sets an event handler that gets called when a call is established.
     * It's only purpose (so far) is to support transitions on video elements.
     * This function is only defined after easyRTC.initManaged is called.
     * The slot argument is the index into the array of video ids.
     * @param {Function} cb has the signature function(easyrtcid, slot) {}
     * @example
     *   easyRTC.setOnCall( function(easyrtcid, slot) { 
     *      console.log("call with " + easyrtcid + "established");
     *   }); 
     */
    easyRTC.setOnCall = function ( cb ) {
        onCall = cb;
    };

    /** Sets an event handler that gets called when a call is ended.
      * it's only purpose (so far) is to support transitions on video elements.
x     * this function is only defined after easyRTC.initManaged is called.
      * The slot is parameter is the index into the array of video ids.
      * Note: if you call easyRTC.getConnectionCount() from inside your callback
      * it's count will reflect the number of connections before the hangup started.
      * @param {Function} cb has the signature function(easyrtcid, slot) {}
     * @example
     *   easyRTC.setOnHangup( function(easyrtcid, slot) { 
     *      console.log("call with " + easyrtcid + "ended");
     *   }); 
      */
    easyRTC.setOnHangup = function( cb ) {
        onHangup = cb;
    }
   
   
    function getIthVideo(i) {
        if( videoIds[i]) {
            return document.getElementById(videoIds[i]);
        }
        else {
            return null;
        }
    }


    easyRTC.getIthCaller = function(i) {
        if( i &lt; 0 || i > videoIds.length) { 
            return null;
        }
        return getIthVideo(i).caller;
    }
    
    easyRTC.getSlotOfCaller = function(easyrtcid) {
        for( var i = 0; i &lt; numPEOPLE; i++) {
            if( easyRTC.getIthCaller(i) == easyrtcid) {
                return i;
            }
        }
        return -1; // caller not connected
    }

    easyRTC.setOnStreamClosed( function (caller) {
        for( var i = 0; i &lt; numPEOPLE; i++ ) {
            var video = getIthVideo(i);
            if( video.caller == caller) {
                easyRTC.setVideoObjectSrc(video, "");
                video.caller = "";
                if( onHangup) {
                    onHangup(caller, i);
                }
            }
        }
    });

    //
    // Only accept incoming calls if we have a free video object to display
    // them in. 
    //
    easyRTC.setAcceptChecker( function(caller, helper) {
        for( var i = 0; i &lt; numPEOPLE; i++) {
            var video = getIthVideo(i);
            if( video.caller == "") {
                helper(true);
                return;
            }
        }
        helper(false);
    });



    easyRTC.setStreamAcceptor( function(caller, stream) {
        if(easyRTC.debugPrinter) {
            easyRTC.debugPrinter("stream acceptor called");
        }
        var i, video;
        if( refreshPane && refreshPane.caller == "") {
            easyRTC.setVideoObjectSrc(video, stream);
            if( onCall) {
                onCall(caller);
            }
            refreshPane = null;
            return;
        }
        for( i = 0; i &lt;numPEOPLE; i++ ) {
            video = getIthVideo(i);
            if( video.caller == caller ) {
                easyRTC.setVideoObjectSrc(video, stream);
                if( onCall) {
                    onCall(caller, i);
                }
                return;
            }
        }

        for( i = 0; i &lt;numPEOPLE; i++ ) {
            video = getIthVideo(i);
            if( video.caller == null || video.caller == "" ) {
                video.caller = caller;
                if( onCall) {
                    onCall(caller, i);
                }
                easyRTC.setVideoObjectSrc(video, stream);
                return;
            }
        }
        //
        // no empty slots, so drop whatever caller we have in the first slot and use that one.
        //
        video = getIthVideo(0);
        if( video ) {
            easyRTC.hangup(video.caller);
            easyRTC.setVideoObjectSrc(video, stream);
            if( onCall) {
                onCall(caller, 0);
            }
        }
        video.caller = caller;
    });


    var addControls = function(video) {
        var parentDiv = video.parentNode;
        video.caller = "";
        var closeButton = document.createElement("button");
        closeButton.className = "closeButton";
        closeButton.onclick = function() {
            if( video.caller) {
                easyRTC.hangup(video.caller);
                easyRTC.setVideoObjectSrc(video, "");
                video.caller = "";
            }
        };
        parentDiv.appendChild(closeButton);
    }


    for( var i = 0; i &lt; numPEOPLE; i++ ) {
        addControls(getIthVideo(i));
    }

    var monitorVideo = null;
    
    if( easyRTC.videoEnabled && monitorVideoId != null) {
        monitorVideo = document.getElementById(monitorVideoId);
        if( !monitorVideo) {           
            alert("Programmer error: no object called " + monitorVideoId);
            return;            
        }
        monitorVideo.muted = true;
        monitorVideo.defaultMuted = true;
    }
    

    var nextInitializationStep;

    // 
    // SIP connectivity is provided in EasyRTC enterprise. The below is a hook
    // for it.
    // 
    if( typeof easyRTC.sipExtrasInit !== 'undefined') {
        if( easyRTC.debugPrinter) {
            easyRTC.debugPrinter("Loading SIP extras");
        }
        nextInitializationStep = function() {
            var remoteVideo = null;
            var remoteAudio = null;
            if( easyRTC.videoEnabled) {
                remoteVideo = getIthVideo(0);            
            }
            if( easyRTC.audioEnabled  ) {
                var remoteAudioId = null, remoteParent = null;
                if(remoteVideo != null) {
                    remoteAudioId = remoteVideo.id + ".audio";
                    remoteAudio = document.getElementById(remoteAudioId);
                    if( !remoteAudio ) {
                        remoteParent = remoteVideo.parentNode;
                        remoteAudio = document.createElement("audio");
                        remoteParent.appendChild(remoteAudio);            
                    }
                }
                else {
                    remoteAudioId = videoIds[0];
                    if( !remoteAudioId ) {
                        remoteAudioId = "remoteAudio";
                    }
                    remoteAudio = document.getElementById(remoteAudioId);
                    if( !remoteAudio) {
                        remoteParent = document.body;
                        remoteAudio = document.createElement("audio");
                        remoteAudio.id = remoteAudioId;
                        remoteParent.appendChild(remoteAudio);            
                    }
                }            
            }
            easyRTC.sipExtrasInit(onReady, monitorVideo, remoteVideo, remoteAudio);
        };
    }
    else {
        if( easyRTC.debugPrinter) {
            easyRTC.debugPrinter("No sip initialization ");
        }
        nextInitializationStep = onReady;
    }

    easyRTC.initMediaSource(
        function() {
            if(  monitorVideo!= null) {
                easyRTC.setVideoObjectSrc(monitorVideo, easyRTC.getLocalStream());
            }
            easyRTC.connect(applicationName,  nextInitializationStep, easyRTC.onError);
        },

        function(errmesg) {
            easyRTC.onError(errmesg);
        }
        );
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="easyRTC.html">easyRTC</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Wed Mar 27 2013 14:16:59 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
</body>
</html>
